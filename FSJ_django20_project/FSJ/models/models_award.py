import uuid
from django.utils.translation import gettext_lazy as _
from django.db import models
from .models_yearofstudy import *
from datetime import datetime
from django.utils import timezone
import pytz
from .models_program import Program
from .models_adjudicator import Adjudicator

class Award(models.Model):
	"""Represents an award which students can apply for.

	awardid -- autogenerated unique ID of the award
	name -- the name of the award
	description -- a description of the award containing important information about requirements, etc.
	value -- the amount of money a student would receive for winning the award
	programs -- the programs eligible for applying to this award
	years_of_study -- the years eligible for applying to this award
	start_date -- marks the start of the period during which students can apply for this award
	end_date -- marks the end of the period during which students can apply for this award
	documents_needed -- a boolean representing whether a student must include documents in their application for this
	award
	is_active -- a boolean representing whether this award is available for students to apply
	adjudicators -- a list of adjudicators who have reviewed this award
	review_comment -- a final comment the coordinator adds to the award record when an adjudication committee has decided
	on the receipient(s) of this award
	"""
	awardid = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
	name = models.CharField(max_length = 255, verbose_name = _("Name"))
	description = models.TextField(verbose_name = _("Description"))
	value = models.CharField(max_length = 100, verbose_name = _("Value"))
	programs = models.ManyToManyField(Program, blank = True, verbose_name = _("Programs"))
	years_of_study = models.ManyToManyField(YearOfStudy, blank = True, verbose_name = _("Years"))
	start_date = models.DateTimeField(auto_now = False, auto_now_add = False, verbose_name = _("Start date"))
	end_date = models.DateTimeField(auto_now = False, auto_now_add = False, verbose_name = _("End Date"))
	documents_needed = models.BooleanField(verbose_name = _("Documents Required"))
	is_active = models.BooleanField(verbose_name = _("Is Active"))
	adjudicators = models.ManyToManyField(Adjudicator, related_name='awards', verbose_name = _("Adjudicators"))
	review_comment = models.CharField(blank = True, max_length = 255, verbose_name = _("Comment"))

	#Returns award name as a string
	def __str__(self):
		return self.name

	#Returns a bool stating whether the award is open or not due to start/end date
	def is_open(self):
		now = timezone.now()
		if self.start_date > now or self.end_date < now:
			return False
		else:
			return True


	def get_review_status(self, FSJ_user):
		"""Returns the review status of the award based on the user asking

		FSJ_user -- the user requesting the review status
		"""

		if self.applications.count() == 0:
			return "No Applications"

		# If the user is a coordinator, review status is based on the number of applications still needing review
		if FSJ_user.user_class() == "Coordinator":
			applications = self.applications.all()
			need_review = 0
			reviewed = 0

			# This counts the number of applications which need review and those which are already reviewed
			for application in applications:

				if application.is_reviewed:
					reviewed += 1
				else:
					need_review += 1

			if reviewed == 0 and need_review >= 1:
				return _("Review Required")

			elif reviewed >= 1 and need_review >= 1:
				return _("Review In Progress")

			elif reviewed >= 1 and need_review == 0:
				return _("Review Completed")

		# If the user is an adjudicator, review status is based purely on whether they have marked this award as
		# reviewed or not.
		elif FSJ_user.user_class() == "Adjudicator":
			if FSJ_user in self.adjudicators.all():
				return _("Review Completed")
			else: 
				applications = self.applications.filter(is_reviewed = True, is_eligible = True, is_archived=False)

				if applications.count() == 0:
					return "No Applications"

				need_review = 0
				for application in applications:
					
					if not application.is_adj_reviewed(FSJ_user):
						need_review += 1

				if need_review == applications.count():
					return _("Review Required")
				else:
					return _("Review In Progress")
			


	def add_reviewed(self, FSJ_user):
		"""Adds an adjudicator to the list of those who have reviewed the award

		FSJ_user -- the adjudicator to be added
		"""
		if FSJ_user not in self.adjudicators.all():
			self.adjudicators.add(FSJ_user)            

	def delete_reviewed(self, FSJ_user):
		"""Removes an adjudicator from the list of those who have reviewed the award

		FSJ_user -- the adjudicator to be removed
		"""
		try:
			self.adjudicators.remove(FSJ_user)
			self.save()
		except:
			pass        	
		
		
	def reset(self, new_start_date=None, new_end_date=None):
		"""Resets an award by deleting all its applications and clearing the list of adjudicators who have reviewed it

		new_start_date -- an optional parameter to change the start date of an award as it is reset (default None)
		new_end_date -- an optional parameter to change the end date of an award as it is reset (default None)
		"""
		
		self.applications.all().delete()
		self.adjudicators.clear()
		if new_start_date:
			self.start_date = new_start_date
		if new_end_date:
			self.end_date = new_end_date
			
	def change_date(self, new_start_date=None, new_end_date=None):
		"""Changes the dates of an award to a new start and/or end date

		new_start_date -- the potential new start date of the award (default None)
		new_end_date -- the potential new end date of the award (default None)
		"""

		if new_start_date:
			self.start_date = new_start_date
		if new_end_date:
			self.end_date = new_end_date	


	def get_start_date(self):
		return

	def all_archived(self):
		"""Checks if all the applications of a particular award have been archived or not"""

		for application in self.applications.all():
			if not application.is_archived:
				return False

		return True

	def get_adj_applications(self):

		return self.applications.filter(is_archived = False, is_reviewed = True, is_eligible=True)